# Repository Goals

## Primary Objective

This repository serves as a **Backend-Focused AI Prompt Engineering Collection** designed for systematic backend development workflows using AI assistants (Cursor, Claude Code, etc.).

## Core Purpose

Build, maintain, and optimize a curated collection of:
- **AI Commands**: Structured prompts for specific backend development tasks
- **AI Rules**: Guidelines that govern how AI assistants should behave in backend contexts
- **Quality Standards**: Best practices for backend development across languages and frameworks

## Scope Definition

### ✅ In Scope
- Backend API development (REST, GraphQL, gRPC)
- Database design, migrations, and optimization
- Server architecture and microservices
- Authentication, authorization, and security
- Performance optimization and monitoring
- DevOps and infrastructure management
- Testing strategies (unit, integration, e2e for backend)
- Backend-specific code quality and standards

### ❌ Out of Scope
- Frontend development (React, Vue, Angular, etc.)
- Full-stack features that mix frontend and backend concerns
- UI/UX design and styling
- Client-side state management
- Browser-specific functionality

## Target Users

- **Backend Engineers**: Using commands for daily development tasks
- **DevOps Engineers**: Using infrastructure and deployment commands
- **Technical Leads**: Enforcing standards through rules
- **AI Prompt Engineers**: Maintaining and optimizing this repository

## Success Criteria

1. **Completeness**: Cover all major backend development workflows
2. **Clarity**: Each command has clear steps, examples, and checklists
3. **Consistency**: Uniform structure and quality across all commands
4. **Maintainability**: Easy to update, test, and extend
5. **Effectiveness**: Commands produce high-quality, production-ready code

## Language Support Priority

1. **Primary**: Go backend development (most detailed rules and commands)
2. **General**: Language-agnostic backend patterns
3. **Future**: Additional language-specific collections (Python, Java, Node.js)

## Quality Principles

- **Precision over verbosity**: Concise, actionable instructions
- **Security-first**: All commands consider security implications
- **Performance-aware**: Optimization is a first-class concern
- **Test-driven**: Testing is integrated, not optional
- **Production-ready**: Code generated should meet production standards

## Repository Health Metrics

- Total active commands: Target 40-50 high-quality commands
- Command coverage: 80%+ of common backend workflows
- Rule clarity: All rules actionable and verifiable
- Update frequency: Review and update quarterly
- Redundancy: Zero overlap between commands
